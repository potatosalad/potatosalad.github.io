<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>potatosalad</title>
 <link href="https://potatosalad.io/atom.xml" rel="self"/>
 <link href="https://potatosalad.io/"/>
 <updated>2016-04-30T11:39:55-06:00</updated>
 <id>https://potatosalad.io</id>
 <author>
   <name>Andrew Bennett</name>
   <email></email>
 </author>

 
 <entry>
   <title>Erlang NIF with timeslice reductions</title>
   <link href="https://potatosalad.io/2016/02/06/erlang-nif-with-timeslice-reductions.html"/>
   <updated>2016-02-06T00:00:00-07:00</updated>
   <id>https://potatosalad.io/2016/02/06/erlang-nif-with-timeslice-reductions</id>
   <content type="html">&lt;p&gt;Recently, I put together an Erlang asynchronous port driver named &lt;a href=&quot;https://github.com/potatosalad/erlang-keccakf1600&quot;&gt;keccakf1600&lt;/a&gt; which implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA-3&lt;/a&gt; algorithms used in another one of my projects, &lt;a href=&quot;https://github.com/potatosalad/erlang-jose&quot;&gt;jose&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See version &lt;a href=&quot;https://github.com/potatosalad/erlang-keccakf1600/tree/1.0.2&quot;&gt;1.0.2 of keccakf1600&lt;/a&gt; for the original port driver implementation.&lt;/p&gt;

&lt;p&gt;When interfacing with native C and the Erlang VM, you essentially have 3 options to choose from:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://erlang.org/doc/tutorial/c_portdriver.html&quot;&gt;Port Driver&lt;/a&gt; &amp;mdash; a shared library linked with &lt;a href=&quot;http://erlang.org/doc/man/driver_entry.html&quot;&gt;&lt;code&gt;driver_entry&lt;/code&gt;&lt;/a&gt; (I/O heavy operations are typically best suited for this type)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://erlang.org/doc/tutorial/nif.html&quot;&gt;NIF&lt;/a&gt; &amp;mdash; a shared library linked with &lt;a href=&quot;http://erlang.org/doc/man/erl_nif.html&quot;&gt;&lt;code&gt;ERL_NIF_INIT&lt;/code&gt;&lt;/a&gt; (fast synchronous operations are typically best suited for this type)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://erlang.org/doc/tutorial/c_port.html&quot;&gt;Port&lt;/a&gt; &amp;mdash; an external program which typically communicates with the Erlang VM over &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My goal was to have a fast and asynchronous way to call blocking functions without disrupting the Erlang VM schedulers from carrying out their work.  The original plan was to use &lt;a href=&quot;http://erlang.org/doc/man/erl_driver.html#driver_async%20&quot;&gt;&lt;code&gt;driver_async&lt;/code&gt;&lt;/a&gt; combined with &lt;a href=&quot;http://erlang.org/doc/man/driver_entry.html#ready_async&quot;&gt;&lt;code&gt;ready_async&lt;/code&gt;&lt;/a&gt; to perform the blocking operations on &amp;ldquo;a thread separate from the emulator thread.&amp;rdquo;  I used the &lt;a href=&quot;http://erlang.org/doc/man/ei.html&quot;&gt;&lt;code&gt;ei&lt;/code&gt;&lt;/a&gt; library in order to communicate between the Erlang VM and the port driver written in C.&lt;/p&gt;

&lt;p&gt;Having accomplished my goal, I decided to run a simple benchmark against the equivalent SHA-2 algorithms out of curiosity as to how my implementation might stack up against the native Erlang &lt;a href=&quot;http://erlang.org/doc/man/crypto.html&quot;&gt;&lt;code&gt;crypto&lt;/code&gt;&lt;/a&gt; library.&lt;/p&gt;

&lt;p&gt;The results were not terribly impressive:&lt;/p&gt;

&lt;div id=&quot;chart1&quot;&gt;
  &lt;svg height=&quot;300&quot;&gt;&lt;/svg&gt;
&lt;/div&gt;

&lt;p&gt;The two main concerns I had with the results were:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Was the SHA-3 implementation I used (based on &lt;a href=&quot;http://sourceforge.net/projects/ed448goldilocks/&quot;&gt;ed448goldilocks&lt;/a&gt;) really 5-7 times slower than the SHA-2 algorithms?&lt;/li&gt;
&lt;li&gt;Why was there so much variance between the SHA-3 algorithms versus the variance observed between the SHA-2 algorithms?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Concern #1 was ruled out by directly testing the C version of the algorithms, for small message sizes they were typically within 1-2Î¼s of each other.&lt;/p&gt;

&lt;p&gt;Concern #2 required more research, which eventually led me to the &lt;a href=&quot;https://github.com/vinoski/bitwise&quot;&gt;bitwise&lt;/a&gt; project by Steve Vinoski.  The project explores some of the strategies for dealing with the synchronous nature of a NIF without blocking the scheduler by keeping track of reductions during a given &lt;a href=&quot;http://erlang.org/doc/man/erl_nif.html#enif_consume_timeslice&quot;&gt;timeslice&lt;/a&gt;.  It also explores strategies using the experimental &lt;a href=&quot;http://erlang.org/doc/man/erl_nif.html#dirty_nifs&quot;&gt;dirty NIF&lt;/a&gt; feature.&lt;/p&gt;

&lt;p&gt;I highly recommend reading the two presentations from the bitwise project: &lt;a href=&quot;https://github.com/vinoski/bitwise/raw/master/vinoski-opt-native-code.pdf&quot;&gt;vinoski-opt-native-code.pdf&lt;/a&gt; and &lt;a href=&quot;https://github.com/vinoski/bitwise/raw/master/vinoski-schedulers.pdf&quot;&gt;vinoski-schedulers.pdf&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After experimenting with the two options, I decided to use &lt;a href=&quot;http://erlang.org/doc/man/erl_nif.html#enif_consume_timeslice&quot;&gt;&lt;code&gt;enif_consume_timeslice&lt;/code&gt;&lt;/a&gt; combined with &lt;a href=&quot;http://erlang.org/doc/man/erl_nif.html#enif_schedule_nif&quot;&gt;&lt;code&gt;enif_schedule_nif&lt;/code&gt;&lt;/a&gt; to yield control back to the main Erlang VM on larger inputs to prevent blocking other schedulers.&lt;/p&gt;

&lt;p&gt;I rewrote the port driver as a NIF and released it as version &lt;a href=&quot;https://github.com/potatosalad/erlang-keccakf1600/tree/2.0.0&quot;&gt;2.0.0 of keccakf1600&lt;/a&gt; and ran the same benchmark again:&lt;/p&gt;

&lt;div id=&quot;chart2&quot;&gt;
  &lt;svg height=&quot;300&quot;&gt;&lt;/svg&gt;
&lt;/div&gt;

&lt;p&gt;These results are much more consistent and closer to my original expectations.  I plan on refactoring the &lt;a href=&quot;https://github.com/potatosalad/erlang-libsodium&quot;&gt;erlang-libsodium&lt;/a&gt; project using the same technique.&lt;/p&gt;

&lt;script&gt;
(function() {
  var seriesData1 = [
    {
      key: &quot;SHA2&quot;,
      values: [
        {
          label: &quot;SHA2/3-224&quot;,
          value: 2.186853
        },
        {
          label: &quot;SHA2/3-256&quot;,
          value: 2.183836
        },
        {
          label: &quot;SHA2/3-384&quot;,
          value: 2.190898
        },
        {
          label: &quot;SHA2/3-512&quot;,
          value: 2.200743
        }
      ]
    },
    {
      key: &quot;SHA3&quot;,
      values: [
        {
          label: &quot;SHA2/3-224&quot;,
          value: 14.37063
        },
        {
          label: &quot;SHA2/3-256&quot;,
          value: 11.97354
        },
        {
          label: &quot;SHA2/3-384&quot;,
          value: 12.42217
        },
        {
          label: &quot;SHA2/3-512&quot;,
          value: 11.8663
        },
        {
          label: &quot;SHAKE128&quot;,
          value: 12.38027
        },
        {
          label: &quot;SHAKE256&quot;,
          value: 12.96572
        }
      ]
    }
  ];
  nv.addGraph(function() {
    var chart = nv.models.multiBarHorizontalChart()
      .x(function(d) { return d.label; })
      .y(function(d) { return d.value; })
      .margin({left: 100, bottom: 75})
      .barColor(d3.scale.category20().range())
      .showValues(true)
      .duration(250)
      .showControls(false)
    ;
    chart.yAxis.axisLabel(&#39;Microseconds (Lower is Better)&#39;);
    d3.select(&quot;#chart1 svg&quot;)
      .datum(seriesData1)
      .call(chart);
    nv.utils.windowResize(chart.update);
    return chart;
  });
  var seriesData2 = [
    {
      key: &quot;SHA2&quot;,
      values: [
        {
          label: &quot;SHA2/3-224&quot;,
          value: 2.186853
        },
        {
          label: &quot;SHA2/3-256&quot;,
          value: 2.183836
        },
        {
          label: &quot;SHA2/3-384&quot;,
          value: 2.190898
        },
        {
          label: &quot;SHA2/3-512&quot;,
          value: 2.200743
        }
      ]
    },
    {
      key: &quot;SHA3&quot;,
      values: [
        {
          label: &quot;SHA2/3-224&quot;,
          value: 3.221057
        },
        {
          label: &quot;SHA2/3-256&quot;,
          value: 3.222021
        },
        {
          label: &quot;SHA2/3-384&quot;,
          value: 3.200662
        },
        {
          label: &quot;SHA2/3-512&quot;,
          value: 3.222704
        },
        {
          label: &quot;SHAKE128&quot;,
          value: 3.228499
        },
        {
          label: &quot;SHAKE256&quot;,
          value: 3.257091
        }
      ]
    }
  ];
  nv.addGraph(function() {
    var chart = nv.models.multiBarHorizontalChart()
      .x(function(d) { return d.label; })
      .y(function(d) { return d.value; })
      .margin({left: 100, bottom: 75})
      .barColor(d3.scale.category20().range())
      .showValues(true)
      .duration(250)
      .showControls(false)
    ;
    chart.yAxis.axisLabel(&#39;Microseconds (Lower is Better)&#39;);
    d3.select(&quot;#chart2 svg&quot;)
      .datum(seriesData2)
      .call(chart);
    nv.utils.windowResize(chart.update);
    return chart;
  });
})();
&lt;/script&gt;
</content>
 </entry>
 

</feed>
